#include <algorithm>
#include <cmath>

#include "decisiontree.h"
#include "assert.h"

DecisionTree::DecisionTree(const AbstractMatType& mat,const CategoricalDescriptor& resp,int groups)
    :response(resp)
{
    matOri.resize(mat.size());

    for(int i=0;i<matOri.size();i++)
        matOri[i] = mat[i]->clone();

    matComp.clear();
    matComp.reserve(matOri.size());

    for(int i=0;i<matOri.size();i++)
    {
        if((matOri[i])->isConvertible())
        {
            std::shared_ptr<ContinuousDescriptor> ContPtr = std::dynamic_pointer_cast<ContinuousDescriptor>(matOri[i]);
            auto addVec = ContPtr->toCategorical();
            int sizeAdded = addVec.size();                          //We add the vector of CategoricalDescriptors generated by Continuous
            std::move(addVec.begin(), addVec.end(), std::back_inserter(matComp));
            addVec.clear();

            std::vector<int> idxVec(sizeAdded);                     //We add the relations between matComp ID and matOri ID
            std::iota(idxVec.begin(),idxVec.end(),matComp.size()-sizeAdded);
            std::transform(idxVec.begin(),idxVec.end(),std::inserter(idxsRelations,idxsRelations.end()),[i](int a){return std::make_pair(a,i);});
        }
        else
        {
            std::shared_ptr<CategoricalDescriptor> CatPtr = std::dynamic_pointer_cast<CategoricalDescriptor>(matOri[i]);
            matComp.push_back(std::move(*CatPtr));

            idxsRelations.emplace(matComp.size()-1,i);
        }
    }

    std::vector<int> vecRespIdx(resp.dataSize());
    std::iota(vecRespIdx.begin(),vecRespIdx.end(),0);
    Pool first(vecRespIdx,resp.getLabels());

    computeTree(first);
}

DecisionTree::DecisionTree(const DecisionTree& other)
    :matComp(other.matComp),response(other.response),
      firstPool(other.firstPool),idxsRelations(other.idxsRelations)
{
    matOri.resize(other.matOri.size());

    for(int i=0;i<matOri.size();i++)
        matOri[i] = other.matOri[i]->clone();
}

DecisionTree& DecisionTree::operator=(const DecisionTree& other)
{
    if(&other != this)
    {
        matComp = other.matComp;
        response = other.response;
        firstPool = other.firstPool;
        idxsRelations = other.idxsRelations;

        matOri.resize(other.matOri.size());

        for(int i=0;i<matOri.size();i++)
            matOri[i] = other.matOri[i]->clone();
    }

    return *this;
}

DecisionTree::DecisionTree(DecisionTree&& other) noexcept
    :matComp(std::move(other.matComp)),response(std::move(other.response)),
      firstPool(std::move(other.firstPool)),idxsRelations(std::move(other.idxsRelations)),
      matOri(std::move(other.matOri))
{

}

DecisionTree& DecisionTree::operator=(DecisionTree&& other) noexcept
{
    assert(this != &other);

    matComp = std::move(other.matComp);
    response = std::move(other.response);
    firstPool = std::move(other.firstPool);
    idxsRelations = std::move(other.idxsRelations);
    matOri = std::move(other.matOri);

    return *this;
}

DecisionTree::AbstractMatType DecisionTree::getOriginalMatrix()
{
    AbstractMatType mat(matOri.size());

    for(int i=0;i<matOri.size();i++)
        mat[i] = matOri[i]->clone();

    return mat;
}

std::vector<CategoricalDescriptor> DecisionTree::getComputationMatrix()
{
    return matComp;
}

CategoricalDescriptor DecisionTree::getResponse()
{
    return response;
}

void DecisionTree::computeTree(Pool& pool)
{
    double max =0;
    int varChosen=0;

    std::vector<int> occurrencesInResp(pool.levelSize());

    for(int j=0;j<pool.levelSize();j++)
        occurrencesInResp[j] = pool.idxs(j).size();

    double firstTerm = entropy(occurrencesInResp,pool.sampleSize());

    for(int i=0;i<matComp.size();i++)
    {
        double calc = infoGain(matComp[i],pool,firstTerm);
        if(calc>max)
        {
            max = calc;
            varChosen = i;
        }
    }
    pool.setVarIdx(varChosen);
    int splits = matComp[varChosen].levelSize();

    for(int j=0;j<splits;j++)
    {
        std::vector<int> descIdxs = matComp[varChosen].idxs(j);
        std::vector<int> respIdxs = pool.allIdxs();
        std::vector<int> intersec;
        intersec.reserve(pool.sampleSize());
        std::set_intersection(descIdxs.begin(),descIdxs.end(),respIdxs.begin(),
                                respIdxs.end(),std::back_inserter(intersec));
         //TODO: Add a function in Pool that returns all the labels given a vec of indexes and use it to build a new Pool
    }
}

double DecisionTree::entropy(const std::vector<int>& partitions, int total)
{
    double res=0;
    for(int i: partitions)
    {
        if(!i)
            continue;
        res -= (i/total)*log2(i/total);
    }
    return res;
}

double DecisionTree::infoGain(const CategoricalDescriptor& desc,const Pool& currPool,double first)
{
    double sum = 0;

    for(int i=0;i<desc.levelSize();i++)
    {
        std::vector<int> descIdxs = desc.idxs(i);
        std::vector<int> probPoolLev(currPool.levelSize());
        for(int j=0;j<currPool.levelSize();j++)
        {
            std::vector<int> respIdxs = currPool.idxs(j);
            std::vector<int> intersec;
            intersec.reserve(currPool.sampleSize());
            std::set_intersection(descIdxs.begin(),descIdxs.end(),respIdxs.begin(),
                                    respIdxs.end(),std::back_inserter(intersec));
            probPoolLev[j] = intersec.size();
        }
        double totPoolInLeaf = static_cast<double>(std::accumulate(probPoolLev.begin(),probPoolLev.end(),0));

        sum +=  (totPoolInLeaf/currPool.sampleSize())*entropy(probPoolLev,totPoolInLeaf);
    }
    return first-sum;
}
