#include <algorithm>

#include "decisiontree.h"
#include "assert.h"

DecisionTree::DecisionTree(const AbstractMatType& mat,const CategoricalDescriptor& resp)
    :response(resp)
{
    matOri.resize(mat.size());

    for(int i=0;i<matOri.size();i++)
        matOri[i] = mat[i]->clone();

    matComp.clear();
    matComp.reserve(matOri.size());

    for(int i=0;i<matOri.size();i++)
    {
        if((matOri[i])->isConvertible())
        {
            std::shared_ptr<ContinuousDescriptor> ContPtr = std::dynamic_pointer_cast<ContinuousDescriptor>(matOri[i]);
            auto addVec = ContPtr->toCategorical();
            int sizeAdded = addVec.size();                          //We add the vector of CategoricalDescriptors generated by Continuous
            std::move(addVec.begin(), addVec.end(), std::back_inserter(matComp));
            addVec.clear();

            std::vector<int> idxVec(sizeAdded);                     //We add the relations between matComp ID and matOri ID
            std::iota(idxVec.begin(),idxVec.end(),matComp.size()-sizeAdded);
            std::transform(idxVec.begin(),idxVec.end(),std::inserter(idxsRelations,idxsRelations.end()),[i](int a){return std::make_pair(a,i);});
        }
        else
        {
            std::shared_ptr<CategoricalDescriptor> CatPtr = std::dynamic_pointer_cast<CategoricalDescriptor>(matOri[i]);
            matComp.push_back(std::move(*CatPtr));

            idxsRelations.emplace(matComp.size()-1,i);
        }
    }

    std::vector<int> vecRespIdx(resp.dataSize());
    std::iota(vecRespIdx.begin(),vecRespIdx.end(),0);
    Pool first(vecRespIdx,resp.getLabels());

    computeTree(first);
}

DecisionTree::DecisionTree(const DecisionTree& other)
    :matComp(other.matComp),response(other.response),
      firstPool(other.firstPool),idxsRelations(other.idxsRelations)
{
    matOri.resize(other.matOri.size());

    for(int i=0;i<matOri.size();i++)
        matOri[i] = other.matOri[i]->clone();
}

DecisionTree& DecisionTree::operator=(const DecisionTree& other)
{
    if(&other != this)
    {
        matComp = other.matComp;
        response = other.response;
        firstPool = other.firstPool;
        idxsRelations = other.idxsRelations;

        matOri.resize(other.matOri.size());

        for(int i=0;i<matOri.size();i++)
            matOri[i] = other.matOri[i]->clone();
    }

    return *this;
}

DecisionTree::DecisionTree(DecisionTree&& other) noexcept
    :matComp(std::move(other.matComp)),response(std::move(other.response)),
      firstPool(std::move(other.firstPool)),idxsRelations(std::move(other.idxsRelations)),
      matOri(std::move(other.matOri))
{

}

DecisionTree& DecisionTree::operator=(DecisionTree&& other) noexcept
{
    assert(this != &other);

    matComp = std::move(other.matComp);
    response = std::move(other.response);
    firstPool = std::move(other.firstPool);
    idxsRelations = std::move(other.idxsRelations);
    matOri = std::move(other.matOri);

    return *this;
}

DecisionTree::AbstractMatType DecisionTree::getOriginalMatrix()
{
    AbstractMatType mat(matOri.size());

    for(int i=0;i<matOri.size();i++)
        mat[i] = matOri[i]->clone();

    return mat;
}

std::vector<CategoricalDescriptor> DecisionTree::getComputationMatrix()
{
    return matComp;
}

CategoricalDescriptor DecisionTree::getResponse()
{
    return response;
}

void DecisionTree::computeTree(Pool& pool)
{
    double max =0;
    for(int i=0;i<matComp.size();i++)
    {
        double calc = infoGain(matComp[i],pool);
        if(calc>max)
        {
            max = calc;
            pool.setVarIdx(i);
            int splits = matComp[i].levelSize();
        }
    }
}

double DecisionTree::entropy(const std::vector<int>& partitions, int total)
{

}

double DecisionTree::infoGain(const CategoricalDescriptor& desc,const Pool& currPool)
{

}
